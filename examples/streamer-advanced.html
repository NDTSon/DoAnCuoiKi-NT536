<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Streamer Dashboard - StreamG8</title>
    <!-- LiveKit Client SDK - Local File -->
    <script src="libs/livekit-client.umd.min.js"></script>
    <style>
        :root {
            --twitch-purple: #9147ff;
            --twitch-purple-hover: #772ce8;
            --bg-body: #0e0e10;
            --bg-base: #18181b;
            --bg-alt: #1f1f23;
            --bg-hover: #26262c;
            --text-base: #efeff1;
            --text-alt: #adadb8;
            --red-live: #eb0400;
            --green-success: #00f593;
            --border-color: #303032;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-base);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Navbar --- */
        .navbar {
            height: 50px;
            background-color: var(--bg-base);
            border-bottom: 1px solid black;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 15px;
            flex-shrink: 0;
            z-index: 1000;
        }

        .nav-logo {
            display: flex;
            align-items: center;
            gap: 10px;
            text-decoration: none;
            color: inherit;
        }

        .nav-logo svg {
            width: 32px;
            height: 32px;
        }

        .nav-logo span {
            font-weight: 800;
            color: var(--twitch-purple);
            font-size: 1.2em;
        }

        .nav-status {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .connection-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 700;
            text-transform: uppercase;
            background: #2f2f35;
            color: var(--text-alt);
        }

        .connection-badge.badge-connected {
            background: var(--green-success);
            color: black;
        }

        .connection-badge.badge-streaming {
            background: var(--red-live);
            color: white;
            animation: pulse 2s infinite;
        }

<<<<<<< Updated upstream
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
=======
        .connection-badge.badge-disconnected {
            background: #333;
            color: #888;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }

            100% {
                opacity: 1;
            }
>>>>>>> Stashed changes
        }

        .user-menu {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .user-avatar-small {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: var(--twitch-purple);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        /* --- Main Layout --- */
        .main-layout {
            display: grid;
            grid-template-columns: 350px 1fr 350px;
            flex: 1;
            height: calc(100vh - 50px);
            overflow: hidden;
        }

        /* --- Panels --- */
        .panel {
            background: var(--bg-base);
            display: flex;
            flex-direction: column;
            border-right: 1px solid black;
            border-left: 1px solid black;
        }

        .panel-header {
            padding: 10px 15px;
            font-weight: 700;
            font-size: 0.9em;
            text-transform: uppercase;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--bg-alt);
        }

        .panel-content {
            padding: 15px;
            overflow-y: auto;
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* --- Forms & Inputs --- */
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        label {
            font-size: 0.85em;
            font-weight: 700;
            color: var(--text-alt);
        }

        input[type="text"],
        select,
        input[type="file"] {
            background: var(--bg-body);
            border: 2px solid transparent;
            color: var(--text-base);
            padding: 8px 10px;
            border-radius: 4px;
            font-family: inherit;
            outline: none;
            transition: 0.2s;
        }

        input[type="text"]:focus,
        select:focus {
            border-color: var(--twitch-purple);
            background: black;
        }

        /* --- Buttons --- */
        .btn {
            border: none;
            border-radius: 4px;
            padding: 10px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            transition: 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--twitch-purple);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--twitch-purple-hover);
        }

        .btn-success {
            background: var(--green-success);
            color: black;
        }

        .btn-success:hover:not(:disabled) {
            opacity: 0.9;
        }

        .btn-danger {
            background: var(--red-live);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            opacity: 0.8;
        }

        .btn-secondary {
            background: var(--bg-hover);
            color: var(--text-base);
        }

        .btn-secondary:hover:not(:disabled) {
            background: #3a3a40;
        }

        .btn.active,
        .quality-btn.active {
            background: var(--twitch-purple);
            color: white;
            border-color: var(--twitch-purple-hover);
        }

        /* --- Middle Video --- */
        .video-wrapper {
            background: black;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .video-container {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        #main-video {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Overlays */
        .stream-overlay-top {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
        }

        .status-pill {
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
            display: flex;
<<<<<<< Updated upstream
        }

        .live-dot {
            width: 10px;
            height: 10px;
            background: white;
            border-radius: 50%;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        #reaction-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .floating-reaction {
            position: absolute;
            font-size: 3em;
            animation: float-up 3s ease-out forwards;
        }

        @keyframes float-up {
            0% {
                transform: translateY(0) scale(1) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(-250px) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }

        .stream-quality-selector {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .stream-quality-selector h3 {
            color: #1f2937;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .quality-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
=======
>>>>>>> Stashed changes
            gap: 10px;
        }

        .live-tag {
            background: var(--red-live);
            color: white;
            padding: 2px 8px;
            border-radius: 2px;
            font-weight: 700;
            display: none;
            /* hidden by default */
        }

        .live-tag.active {
            display: block;
        }

        .stats-bar {
            background: var(--bg-alt);
            height: 60px;
            border-top: 1px solid black;
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding: 0 20px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: 700;
        }

        .stat-label {
            font-size: 0.75em;
            color: var(--text-alt);
            text-transform: uppercase;
        }

        /* --- Chat --- */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.9em;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .chat-message {
            word-wrap: break-word;
        }

        .chat-message .sender {
            color: var(--twitch-purple);
            font-weight: 700;
            margin-right: 5px;
        }

        .chat-input-wrapper {
            padding: 15px;
            background: var(--bg-alt);
            border-top: 1px solid var(--border-color);
        }

        /* --- Reactions --- */
        .reactions-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
            padding: 10px;
            background: var(--bg-alt);
            border-top: 1px solid var(--border-color);
        }

        .reaction-btn {
            background: transparent;
            border: 1px solid transparent;
            font-size: 1.5em;
            cursor: pointer;
            border-radius: 4px;
        }

        .reaction-btn:hover {
            background: var(--bg-hover);
        }

        #reaction-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            overflow: hidden;
        }

        .floating-reaction {
            position: absolute;
            bottom: 20px;
            font-size: 2.5em;
            animation: floatUp 3s ease-out forwards;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 0;
            }

            10% {
                opacity: 1;
                transform: translateY(-50px) scale(1.2);
            }

            100% {
                transform: translateY(-400px) scale(1);
                opacity: 0;
            }
        }

        /* Mobile */
        @media (max-width: 1024px) {
            .main-layout {
                grid-template-columns: 1fr;
            }

            .panel {
                height: auto;
                border: none;
                border-bottom: 1px solid black;
            }
        }
    </style>
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar">
        <a href="live-streams.html" class="nav-logo">
            <svg viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                <defs>
                    <linearGradient id="g1" x1="0" y1="0" x2="40" y2="40" gradientUnits="userSpaceOnUse">
                        <stop offset="0%" stop-color="#00C7FD" />
                        <stop offset="100%" stop-color="#9146FF" />
                    </linearGradient>
                </defs>
                <path
                    d="M33.5 17.4C35.5 18.55 35.5 21.45 33.5 22.6L13.5 34.15C11.5 35.3 9 33.85 9 31.55V8.45C9 6.15 11.5 4.7 13.5 5.85L33.5 17.4Z"
                    fill="url(#g1)" />
            </svg>
            <span>StreamG8</span>
        </a>

        <div class="nav-status">
            <div id="connection-status" class="connection-badge badge-disconnected">Offline</div>
            <div class="user-menu">
                <div class="user-avatar-small">S</div>
                <span id="user-name" style="font-weight: 600; font-size: 0.9em;">Streamer</span>
            </div>
        </div>
    </nav>

    <!-- Layout -->
    <div class="main-layout">

        <!-- Left Panel: Controls -->
        <div class="panel">
            <div class="panel-header">Thi·∫øt l·∫≠p Stream</div>
            <div class="panel-content">

                <div class="form-group">
                    <label>Th√¥ng tin</label>
                    <input type="text" id="streamer-name" placeholder="T√™n hi·ªÉn th·ªã" value="Streamer">
                    <input type="text" id="stream-title" placeholder="Ti√™u ƒë·ªÅ Stream">
                </div>

                <div class="form-group">
                    <label>Ngu·ªìn ph√°t</label>
                    <select id="stream-source" onchange="handleSourceChange()">
                        <option value="camera">üìπ Camera / M√†n h√¨nh</option>
                        <option value="file">üìÅ Upload File Video</option>
                    </select>
                </div>

                <div class="form-group" id="file-input-group" style="display:none;">
                    <label>Ch·ªçn Video</label>
                    <input type="file" id="video-file-input" accept="video/*">
                </div>

                <div style="margin-top: 10px; display: flex; flex-direction: column; gap: 10px;">
                    <button id="btn-start-stream" class="btn btn-primary">‚ñ∂ B·∫Øt ƒë·∫ßu Stream</button>
                    <button id="btn-stop-stream" class="btn btn-danger" disabled>‚¨õ K·∫øt th√∫c Stream</button>
                </div>

                <div class="form-group" style="margin-top: 20px;">
                    <label>ƒêi·ªÅu khi·ªÉn</label>
                    <button id="btn-toggle-mic" class="btn btn-secondary">üé§ Mic: ON</button>
                    <button id="btn-toggle-camera" class="btn btn-secondary">üìπ Camera: OFF</button>
                    <button id="btn-screen-share" class="btn btn-secondary" disabled>üñ•Ô∏è Chia s·∫ª m√†n h√¨nh</button>
                </div>

                <div class="form-group" style="margin-top: 20px;">
                    <label>Ch·∫•t l∆∞·ª£ng</label>
                    <div style="display: flex; gap: 5px;">
                        <button class="quality-btn btn btn-secondary" data-quality="auto">Auto</button>
                        <button class="quality-btn btn btn-secondary" data-quality="1080p">1080p</button>
                        <button class="quality-btn btn btn-secondary" data-quality="144p">Low</button>
                    </div>
                </div>

            </div>
        </div>

<<<<<<< Updated upstream
        <!-- Main Layout -->
        <div class="main-layout">
            <!-- Left Panel -->
            <div class="left-panel">
                <!-- Stream Info Section -->
                <div class="stream-key-section">
                    <h3>üìù Stream Information</h3>
                    <div style="display: flex; flex-direction: column; gap: 12px;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #374151;">Your Name</label>
                            <input type="text" id="streamer-name" placeholder="Enter your name" 
                                   style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 600; color: #374151;">Stream Title</label>
                            <input type="text" id="stream-title" placeholder="Enter stream title" 
                                   style="width: 100%; padding: 10px; border: 2px solid #e5e7eb; border-radius: 8px; font-size: 14px;">
                        </div>
                    </div>
                </div>

                <!-- Video Container -->
                <div class="video-container">
                    <video id="main-video" autoplay playsinline muted></video>
                    
                    <div class="video-overlay">
                        <div class="stream-info-overlay" id="stream-info">
                            <div>‚è±Ô∏è Duration: <span id="stream-duration">00:00</span></div>
                            <div>üëÅÔ∏è Viewers: <span id="stream-viewers">0</span></div>
                        </div>
                        
                        <div class="live-indicator" id="live-indicator">
                            <div class="live-dot"></div>
                            <span>LIVE</span>
                        </div>
                        
                        <div id="reaction-overlay"></div>
                        
                        <div class="stream-controls-overlay">
                            <button class="btn btn-success" id="btn-start-stream">‚ñ∂Ô∏è Start Stream</button>
                            <button class="btn btn-danger" id="btn-stop-stream" disabled>‚èπÔ∏è Stop Stream</button>
                            <button class="btn btn-warning" id="btn-screen-share">üñ•Ô∏è Screen Share</button>
                            <button class="btn btn-primary" id="btn-toggle-mic">üé§ Mic: ON</button>
                            <button class="btn btn-primary" id="btn-toggle-camera">üìπ Camera: OFF</button>
                        </div>
                    </div>
                </div>

                <!-- Stream Quality Selector -->
                <div class="stream-quality-selector">
                    <h3>üìä Ch·∫•t l∆∞·ª£ng Stream</h3>
                    <div class="quality-options">
                        <div class="quality-btn active" data-quality="1080p">
                            <div class="quality-label">1080p</div>
                            <div class="quality-desc">Full HD</div>
                        </div>
                        <div class="quality-btn" data-quality="720p">
                            <div class="quality-label">720p</div>
                            <div class="quality-desc">HD</div>
                        </div>
                        <div class="quality-btn" data-quality="480p">
                            <div class="quality-label">480p</div>
                            <div class="quality-desc">SD</div>
                        </div>
                        <div class="quality-btn" data-quality="auto">
                            <div class="quality-label">Auto</div>
                            <div class="quality-desc">Adaptive</div>
                        </div>
                    </div>
                </div>

                <!-- Statistics Grid -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <h4>üë• Viewers</h4>
                        <div class="stat-value" id="stat-current-viewers">0</div>
                        <div class="stat-change positive">üìà Peak: <span id="stat-peak-viewers">0</span></div>
                    </div>
                    <div class="stat-card">
                        <h4>üí¨ Messages</h4>
                        <div class="stat-value" id="stat-messages">0</div>
                        <div class="stat-change positive">+<span id="stat-messages-rate">0</span>/min</div>
                    </div>
                    <div class="stat-card">
                        <h4>‚ù§Ô∏è Reactions</h4>
                        <div class="stat-value" id="stat-reactions">0</div>
                        <div class="stat-change positive">+<span id="stat-reactions-rate">0</span>/min</div>
                    </div>
                    <div class="stat-card">
                        <h4>‚è±Ô∏è Duration</h4>
                        <div class="stat-value" id="stat-total-duration">00:00:00</div>
                        <div class="stat-change">üî¥ Live</div>
=======
        <!-- Center: Video -->
        <div class="video-wrapper">
            <div class="video-container">
                <video id="main-video" autoplay playsinline muted></video>
                <div id="reaction-overlay"></div>

                <div class="stream-overlay-top">
                    <!-- Status -->
                    <div class="status-pill">
                        <div id="live-indicator" class="live-tag">LIVE</div>
                        <span id="stream-duration">00:00</span>
                    </div>
                    <!-- Viewers -->
                    <div class="status-pill">
                        üëÅÔ∏è <span id="stream-viewers">0</span>
>>>>>>> Stashed changes
                    </div>
                </div>
            </div>

            <!-- Stats Bar -->
            <div class="stats-bar">
                <div class="stat-item">
                    <div class="stat-value" id="stat-current-viewers">0</div>
                    <div class="stat-label">Ng∆∞·ªùi xem</div>
                </div>
                <!-- Hidden helper stats to satisfy JS logic -->
                <span id="stat-peak-viewers" style="display:none;">0</span>

                <div class="stat-item">
                    <div class="stat-value" id="stat-messages">0</div>
                    <div class="stat-label">Tin nh·∫Øn</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-reactions">0</div>
                    <div class="stat-label">C·∫£m x√∫c</div>
                </div>

                <span id="stat-messages-rate" style="display:none;">0</span>
                <span id="stat-reactions-rate" style="display:none;">0</span>
                <span id="stat-total-duration" style="display:none;">0</span>
            </div>
        </div>

        <!-- Right Panel: Social -->
        <div class="panel">
            <div class="panel-header">T∆∞∆°ng t√°c</div>

            <div class="chat-container">
                <div class="chat-messages" id="chat-messages">
                    <div class="chat-message" style="color: var(--text-alt); text-align: center; font-style: italic;">
                        H·ªá th·ªëng s·∫µn s√†ng...
                    </div>
                </div>
            </div>

            <div class="chat-input-wrapper">
                <input type="text" id="chat-input" placeholder="G·ª≠i tin nh·∫Øn..." style="width: 100%;">
                <button id="btn-send-chat" style="display:none;">Send</button> <!-- Hidden triggers on enter -->
            </div>

            <!-- Quick Reactions -->
            <div class="reactions-grid">
                <button class="reaction-btn" data-reaction="heart">‚ù§Ô∏è</button>
                <button class="reaction-btn" data-reaction="laugh">üòÇ</button>
                <button class="reaction-btn" data-reaction="wow">üòÆ</button>
                <button class="reaction-btn" data-reaction="fire">üî•</button>
                <button class="reaction-btn" data-reaction="clap">üëè</button>
                <button class="reaction-btn" data-reaction="like">üëç</button>
                <button class="reaction-btn" data-reaction="sad">üò¢</button>
                <button class="reaction-btn" data-reaction="party">üéâ</button>
            </div>

            <!-- Hidden containers for JS compatibility -->
            <div id="viewers-list" style="display:none;"></div>
            <div id="viewers-count" style="display:none;"></div>
            <div id="chat-count" style="display:none;"></div>
            <div id="reaction-stats" style="display:none;"></div>
            <div id="notifications-list" style="display:none;"></div>

        </div>
    </div>

    <!-- ORIGINAL JAVASCRIPT Logic -->
    <script>
        // Configuration - Dynamic with File Protocol Support
        let API_URL = 'http://localhost:7880/api/streaming';
        let WS_URL = 'ws://localhost:7880/api/streaming';
        let LIVEKIT_URL = 'ws://localhost:7880';

        if (window.location.protocol !== 'file:') {
            const PROTOCOL = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const HOST = window.location.host;
            API_URL = '/api/streaming';
            WS_URL = `${PROTOCOL}//${HOST}/api/streaming`;
            LIVEKIT_URL = `${PROTOCOL}//${HOST}`;
        }

        let ROOM_NAME = 'advanced-stream-' + Date.now();
        let USER_ID = 'streamer-' + Math.random().toString(36).substr(2, 9);
        let USER_DISPLAY_NAME = 'Streamer';
        let currentRoomId = ROOM_NAME; // Stream ID for directory

        // State
        let isStreaming = false;
        let streamStartTime = null;
        let durationInterval = null;
        let localStream = null;
        let chatWebSocket = null;
        let reactionsWebSocket = null;
        let micEnabled = true;
        let cameraEnabled = false;
        let currentQuality = '1080p';
        
        // LiveKit state
        let livekitRoom = null;
        let localVideoTrack = null;
        let localAudioTrack = null;

        // Statistics
        const stats = {
            viewers: 0,
            peak: 0,
            messages: 0,
            reactions: 0,
            messagesLastMinute: 0,
            reactionsLastMinute: 0
        };

        const reactionCounts = {};

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Check if LiveKit SDK loaded
            if (typeof LivekitClient === 'undefined') {
                console.error('‚ùå LiveKit SDK not loaded!');
                alert('‚ùå Error: LiveKit SDK failed to load. Please refresh the page.');
                return;
            }
            console.log('‚úÖ LiveKit SDK loaded successfully');
            
            setupEventListeners();
            updateUIState();
<<<<<<< Updated upstream
            document.getElementById('user-name').textContent = USER_ID.substring(0, 15);
            
=======

>>>>>>> Stashed changes
            // Set default values
            // Check for logged in user - Priority: URL Params > LocalStorage > Default
            const urlParams = new URLSearchParams(window.location.search);
            const urlName = urlParams.get('name');
            const urlEmail = urlParams.get('email');

            // If present in URL, save to storage (sync across tabs/file-protocol)
            if (urlName) {
                localStorage.setItem('user_name', urlName);
                if (urlEmail) localStorage.setItem('user_email', urlEmail);
            }

            const storedName = urlName || localStorage.getItem('user_name');
            const storedEmail = urlEmail || localStorage.getItem('user_email');

            if (storedName) {
                // Use stored identity
                USER_DISPLAY_NAME = storedName;
                document.getElementById('streamer-name').value = storedName;
                document.getElementById('user-name').textContent = storedName;

                // Optional: Make ID consistent based on email if available
                if (storedEmail) {
                    USER_ID = 'streamer-' + storedEmail.split('@')[0];
                }
            } else {
                // Default random identity
                const defaultName = 'Streamer ' + USER_ID.substring(9, 13); // Shorten ID for default name
                document.getElementById('streamer-name').value = defaultName;
                document.getElementById('user-name').textContent = defaultName;
            }

            document.getElementById('stream-title').value = 'My Live Stream ' + new Date().toLocaleDateString('vi-VN');

            // Dynamic header update listener
            document.getElementById('streamer-name').addEventListener('input', (e) => {
                document.getElementById('user-name').textContent = e.target.value || 'Streamer';
            });
        });

        function setupEventListeners() {
            // Stream controls
            document.getElementById('btn-start-stream').addEventListener('click', startStream);
            document.getElementById('btn-stop-stream').addEventListener('click', stopStream);
            document.getElementById('btn-screen-share').addEventListener('click', shareScreen);
            document.getElementById('btn-toggle-mic').addEventListener('click', toggleMic);
            document.getElementById('btn-toggle-camera').addEventListener('click', toggleCamera);

            // Chat
            document.getElementById('btn-send-chat').addEventListener('click', sendChatMessage);
            document.getElementById('chat-input').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') sendChatMessage();
            });

            // Reactions
            document.querySelectorAll('.reaction-btn').forEach(btn => {
                btn.addEventListener('click', () => sendReaction(btn.dataset.reaction));
            });

            // Quality selector
            document.querySelectorAll('.quality-btn').forEach(btn => {
                btn.addEventListener('click', () => selectQuality(btn));
            });
        }

        // Register stream in Server Memory
        async function registerStreamInDirectory() {
            try {
                const streamerName = document.getElementById('streamer-name')?.value || 'Anonymous Streamer';
                const streamTitle = document.getElementById('stream-title')?.value || 'Untitled Stream';
                
                const streamData = {
                    id: currentRoomId,
                    title: streamTitle,
                    streamer: streamerName,
                    avatar: `https://ui-avatars.com/api/?name=${encodeURIComponent(streamerName)}&background=6366f1&color=fff&size=128`,
                    viewers: 0,
                    startTime: Date.now(),
                    // reactions etc aren't stored on server yet, but that's fine for listing
                };

                // Call Server API
                const response = await fetch(`${API_URL}/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(streamData)
                });

                if (response.ok) {
                    console.log('‚úÖ Stream registered on server:', streamData);
                } else {
                    console.error('‚ùå Failed to register stream on server');
                }
            } catch (error) {
                console.error('Error registering stream:', error);
            }
        }

        // Unregister stream from Server Memory
        async function unregisterStreamFromDirectory() {
            try {
                // Call Server API
                const response = await fetch(`${API_URL}/unregister`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: currentRoomId })
                });

                if (response.ok) {
                    console.log('‚úÖ Stream unregistered from server');
                } else {
                    console.error('‚ùå Failed to unregister stream');
                }
            } catch (error) {
                console.error('Error unregistering stream:', error);
            }
        }

<<<<<<< Updated upstream
        async function startStream() {
            try {
                // Prevent multiple starts
                if (isStreaming || livekitRoom) {
                    console.warn('‚ö†Ô∏è Stream already running or room exists!');
                    return;
                }
                
                isStreaming = true;
                updateUIState();
                addNotification('üé¨ Starting stream...', 'success');
                
                // Reset stats at start
                stats.viewers = 0;
                stats.messages = 0;
                stats.reactions = 0;
                stats.peak = 0;
=======
        // === Source Handling Globals ===
        let videoFileElement = null;

        function handleSourceChange() {
            const source = document.getElementById('stream-source').value;
            const fileGroup = document.getElementById('file-input-group');
            if (fileGroup) fileGroup.style.display = source === 'file' ? 'block' : 'none';
        }

        // === Reusable Setup Functions ===

        async function commonRoomSetup() {
            livekitRoom.on(LivekitClient.RoomEvent.ParticipantConnected, (participant) => {
                const count = Array.from(livekitRoom.remoteParticipants.values()).length;
                stats.viewers = count;
>>>>>>> Stashed changes
                updateStats();

                // Parse friendly name
                // Priority: metadata name > identity cleaned
                let name = participant.name;
                if (!name || name === participant.identity) {
                    // If name missing or same as ID, try to clean ID
                    name = participant.identity || "Kh√°ch";
                    // Remove session suffix if present (e.g. user-sess-123 -> user)
                    name = name.replace(/-sess-[a-zA-Z0-9]+$/, '');
                    // Rename cleaned if still has dashes and looks like it wasn't cleaned properly
                    if (name.length > 20 && name.includes('-')) name = name.split('-')[0];
                }

                addSystemMessage(`üëã ${name} ƒë√£ tham gia stream`);
            });
            livekitRoom.on(LivekitClient.RoomEvent.ParticipantDisconnected, (participant) => {
                const count = Array.from(livekitRoom.remoteParticipants.values()).length;
                stats.viewers = count;
                updateStats();

                let name = participant.name;
                if (!name || name === participant.identity) {
                    name = participant.identity || "Kh√°ch";
                    name = name.replace(/-sess-[a-zA-Z0-9]+$/, '');
                    if (name.length > 20 && name.includes('-')) name = name.split('-')[0];
                }
                addSystemMessage(`üí® ${name} ƒë√£ r·ªùi ƒëi`);
            });
            livekitRoom.on(LivekitClient.RoomEvent.DataReceived, (payload, participant) => {
                try {
                    const text = new TextDecoder().decode(payload);
                    const data = JSON.parse(text);
                    if (data.type === 'chat') {
                        const chatMessages = document.getElementById('chat-messages');
                        if (chatMessages) {
                            const messageDiv = document.createElement('div');
                            messageDiv.className = 'chat-message';
                            messageDiv.innerHTML = `<span class="sender">${participant?.identity || data.sender_name}:</span><span class="content">${data.content}</span>`;
                            chatMessages.appendChild(messageDiv);
                        }
                        stats.messages++;
                        updateStats();
                    } else if (data.type === 'reaction') {
                        showReactionAnimation(data);
                        stats.reactions++;
                        updateStats();
                    }
                } catch (e) { }
            });

            // === Setup Room Events ===
            livekitRoom.on(LivekitClient.RoomEvent.TrackSubscribed, (track, publication, participant) => {
                console.log('üé• Track subscribed from:', participant.identity, track.kind);
            });

            livekitRoom.on(LivekitClient.RoomEvent.Disconnected, () => {
                console.log('Disconnected from room');
                isStreaming = false;
                updateUIState();
            });
        }

        async function setupLiveKitAndPublish(videoStream, audioStream) {
            addNotification('üîó Connecting to LiveKit...', 'info');

            livekitRoom = new LivekitClient.Room({
                adaptiveStream: true,
                dynacast: true,
                publishDefaults: {
                    simulcast: true,
                    videoCodec: 'vp8',
                    // Config for CAMERA/FILE
                    videoSimulcastLayers: [
                        { width: 1920, height: 1080, encoding: { maxBitrate: 3_000_000, maxFramerate: 30 } },
                        { width: 256, height: 144, encoding: { maxBitrate: 100_000, maxFramerate: 15 } }
                    ],
                    // Config for SCREEN SHARE
                    screenShareSimulcastLayers: [
                        { width: 1920, height: 1080, encoding: { maxBitrate: 3_000_000, maxFramerate: 30 } },
                        { width: 256, height: 144, encoding: { maxBitrate: 100_000, maxFramerate: 5 } }
                    ]
                }
            });

            await commonRoomSetup();

            await livekitRoom.connect(LIVEKIT_URL, token);
            console.log('‚úÖ Connected to LiveKit Room:', livekitRoom.name);
            addNotification(`üîó Connected to room: ${livekitRoom.name}`, 'success');

            // Publish Tracks
            addNotification('üì° Publishing stream...', 'info');

            const videoTrack = videoStream.getVideoTracks()[0];
            localVideoTrack = new LivekitClient.LocalVideoTrack(videoTrack);

            const source = document.getElementById('stream-source').value;
            const trackSource = source === 'file' ? LivekitClient.Track.Source.Camera : LivekitClient.Track.Source.ScreenShare;

            await livekitRoom.localParticipant.publishTrack(localVideoTrack, {
                source: trackSource,
                simulcast: true
            });

            const audioTracks = videoStream.getAudioTracks();
            if (audioTracks.length > 0) {
                const track = new LivekitClient.LocalAudioTrack(audioTracks[0]);
                await livekitRoom.localParticipant.publishTrack(track, {
                    source: LivekitClient.Track.Source.ScreenShareAudio
                });
            }

            if (audioStream) {
                const track = audioStream.getAudioTracks()[0];
                localAudioTrack = new LivekitClient.LocalAudioTrack(track);
                await livekitRoom.localParticipant.publishTrack(localAudioTrack, {
                    source: LivekitClient.Track.Source.Microphone
                });
            }
        }

        async function startStream() {
            if (isStreaming) return;

            const roomNameInput = document.getElementById('stream-title').value;
            const streamerNameInput = document.getElementById('streamer-name').value;
            if (!roomNameInput || !streamerNameInput) {
                addNotification('‚ùå Please enter stream title and name', 'error');
                return;
            }

            USER_DISPLAY_NAME = streamerNameInput;
            ROOM_NAME = roomNameInput + '-' + Math.floor(Math.random() * 1000);
            currentRoomId = ROOM_NAME;

            // For OBS Sync
            if (document.getElementById('stream-source').value === 'obs') {
                ROOM_NAME = "stream-room"; // Force strictly to match the default instruction
            }

            // Update UI
            // Reset stats at start
            stats.viewers = 0;
            stats.messages = 0;
            stats.reactions = 0;
            updateStats();

            const startBtn = document.getElementById('btn-start-stream') || document.getElementById('btn-start');
            if (startBtn) {
                startBtn.disabled = true;
                startBtn.innerHTML = '‚è≥ Starting...';
            }

            try {
                // Get Token (Generic for all sources)
                const response = await fetch(`${API_URL}/token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        room_name: ROOM_NAME,
                        identity: USER_ID,
                        name: USER_DISPLAY_NAME,
                        is_publisher: true
                    })
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`Failed to get token: ${response.status} ${errorText}`);
                }

                const data = await response.json();
                token = data.token;
                console.log('‚úÖ Got access token');

                connectWebSockets(); // Initialize WebSockets

<<<<<<< Updated upstream
                // Step 3: Get user media (screen + audio)
                addNotification('üé• Requesting screen share...', 'info');
                
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: { displaySurface: 'monitor', width: 1920, height: 1080 },
                    audio: false
                });

                const audioStream = await navigator.mediaDevices.getUserMedia({
                    audio: true,
                    video: false
                });

                // Combine tracks
                const videoTrack = screenStream.getVideoTracks()[0];
                const audioTrack = audioStream.getAudioTracks()[0];
                
                localStream = new MediaStream([videoTrack, audioTrack]);
                document.getElementById('main-video').srcObject = localStream;

                // Step 4: Connect to LiveKit Room
                addNotification('üîó Connecting to LiveKit...', 'info');
                
                livekitRoom = new LivekitClient.Room();
                
                // Setup room event listeners
                livekitRoom.on(LivekitClient.RoomEvent.ParticipantConnected, (participant) => {
                    // Count actual remote participants only (viewers)
                    const actualCount = Array.from(livekitRoom.remoteParticipants.values()).length;
                    console.log('‚úÖ Viewer joined:', participant.identity, '| Actual viewers:', actualCount);
                    stats.viewers = actualCount;
                    stats.peak = Math.max(stats.peak, stats.viewers);
                    updateStats();
                    addNotification(`üë§ Viewer joined`, 'info');
                });

                livekitRoom.on(LivekitClient.RoomEvent.ParticipantDisconnected, (participant) => {
                    // Count actual remote participants only (viewers)
                    const actualCount = Array.from(livekitRoom.remoteParticipants.values()).length;
                    console.log('‚ùå Viewer left:', participant.identity, '| Actual viewers:', actualCount);
                    stats.viewers = actualCount;
                    updateStats();
                    addNotification(`üë§ Viewer left`, 'info');
                });

                // Listen for data messages from viewers (chat/reactions via LiveKit)
                livekitRoom.on(LivekitClient.RoomEvent.DataReceived, (payload, participant) => {
                    console.log('üîî DataReceived event fired!', {
                        payloadSize: payload.byteLength,
                        from: participant?.identity
                    });
                    
                    try {
                        const decoder = new TextDecoder();
                        const text = decoder.decode(payload);
                        console.log('üì¶ Decoded text:', text);
                        
                        const data = JSON.parse(text);
                        console.log('üìã Parsed data:', data);
                        
                        if (data.type === 'chat') {
                            console.log('ÔøΩ Processing chat message:', data.content);
                            
                            // Add to chat display
                            const chatMessages = document.getElementById('chat-messages');
                            if (!chatMessages) {
                                console.error('‚ùå chat-messages element not found!');
                                return;
                            }
                            
                            const messageDiv = document.createElement('div');
                            messageDiv.className = 'chat-message';
                            messageDiv.innerHTML = `
                                <div class="message-sender">
                                    <span>${participant?.identity || data.sender_name || 'Viewer'}</span>
                                    <span class="message-time">${new Date().toLocaleTimeString('vi-VN', {hour: '2-digit', minute: '2-digit'})}</span>
                                </div>
                                <div class="message-content">${data.content}</div>
                            `;
                            chatMessages.appendChild(messageDiv);
                            chatMessages.scrollTop = chatMessages.scrollHeight;
                            
                            console.log('‚úÖ Chat message added to UI');
                            
                            stats.messages++;
                            updateStats();
                        } else if (data.type === 'reaction') {
                            console.log('‚ù§Ô∏è Reaction via LiveKit:', data.reaction_type);
                            // Show reaction animation
                            if (typeof showReactionAnimation === 'function') {
                                showReactionAnimation(data);
                            }
                            stats.reactions++;
                            updateStats();
                        } else {
                            console.log('‚ö†Ô∏è Unknown data type:', data.type);
                        }
                    } catch (e) {
                        console.error('‚ùå Error processing data:', e, e.stack);
=======
                // Determine Source
                const source = document.getElementById('stream-source').value;
                let videoStream;
                let audioStream;

                if (source === 'file') {
                    // === FILE MODE ===
                    const fileInput = document.getElementById('video-file-input');
                    const file = fileInput.files[0];
                    if (!file) throw new Error("Vui l√≤ng ch·ªçn Video File tr∆∞·ªõc!");

                    // Create hidden video element to play file
                    if (videoFileElement) videoFileElement.remove();
                    videoFileElement = document.createElement('video');
                    videoFileElement.src = URL.createObjectURL(file);
                    videoFileElement.loop = true;
                    videoFileElement.muted = false;
                    videoFileElement.play();

                    if (videoFileElement.captureStream) {
                        videoStream = videoFileElement.captureStream();
                    } else if (videoFileElement.mozCaptureStream) {
                        videoStream = videoFileElement.mozCaptureStream();
                    } else {
                        throw new Error("Browser does not support captureStream()");
>>>>>>> Stashed changes
                    }

<<<<<<< Updated upstream
                // Connect to room
                await livekitRoom.connect(LIVEKIT_URL, token);
                console.log('‚úÖ Connected to LiveKit room:', ROOM_NAME);
                
                // Initialize viewer count - wait for participants to be ready
                setTimeout(() => {
                    const remoteCount = Array.from(livekitRoom.remoteParticipants.values()).length;
                    stats.viewers = remoteCount;
                    stats.peak = Math.max(stats.peak, stats.viewers);
                    updateStats();
                    console.log('üìä Initial viewer count:', stats.viewers, 'remote participants');
                }, 500);

                // Step 5: Publish tracks
                addNotification('üì° Publishing stream...', 'info');
                
                localVideoTrack = new LivekitClient.LocalVideoTrack(videoTrack);
                await livekitRoom.localParticipant.publishTrack(localVideoTrack);
                
                localAudioTrack = new LivekitClient.LocalAudioTrack(audioTrack);
                await livekitRoom.localParticipant.publishTrack(localAudioTrack);

                console.log('‚úÖ Published video and audio tracks');

                // Step 6: Start timer and register
                streamStartTime = Date.now();
                startDurationTimer();
                document.getElementById('live-indicator').classList.add('active');
                
                registerStreamInDirectory();
                
                addNotification('üî¥ Stream LIVE! Viewers can now watch!', 'success');
                updateConnectionStatus('streaming');
                
            } catch (error) {
                console.error('Error starting stream:', error);
                addNotification('‚ùå Failed to start stream: ' + error.message, 'error');
                
                // Cleanup on error
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                    localStream = null;
                }
                if (livekitRoom) {
                    livekitRoom.disconnect();
                    livekitRoom = null;
                }
                
                isStreaming = false;
                updateUIState();
            }
        }

=======
                    audioStream = null;

                    // Set local preview
                    document.getElementById('main-video').srcObject = videoStream;
                    document.getElementById('main-video').muted = true;

                    await setupLiveKitAndPublish(videoStream, audioStream);

                } else {
                    // === CAMERA / SCREEN MODE (Standard) ===
                    addNotification('üé• Requesting media...', 'info');

                    videoStream = await navigator.mediaDevices.getDisplayMedia({
                        video: { displaySurface: 'monitor', width: { ideal: 1920 }, height: { ideal: 1080 } },
                        audio: true
                    });

                    try {
                        audioStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                    } catch (e) {
                        console.warn('Could not get mic:', e);
                    }

                    const tracks = [...videoStream.getVideoTracks()];
                    if (audioStream) tracks.push(...audioStream.getAudioTracks());
                    localStream = new MediaStream(tracks);
                    document.getElementById('main-video').srcObject = localStream;

                    await setupLiveKitAndPublish(videoStream, audioStream);
                }

                // Common Success Steps
                isStreaming = true;
                const stopBtn = document.getElementById('btn-stop-stream') || document.getElementById('btn-stop');
                if (stopBtn) stopBtn.disabled = false;
                if (startBtn) startBtn.style.display = 'none';

                // Register in Directory
                registerStreamInDirectory();

                // Start Timer
                streamStartTime = Date.now();
                startDurationTimer();
                const indicator = document.getElementById('live-indicator');
                if (indicator) indicator.classList.add('active');

                // Recording (Optional)
                if (source !== 'obs') startRecording();

                addNotification('üî¥ Stream LIVE!', 'success');
                updateConnectionStatus('streaming');

                // Update Camera State
                if (source === 'camera') {
                    cameraEnabled = true;
                } else {
                    cameraEnabled = false;
                }
                updateUIState();

            } catch (error) {
                console.error('Error:', error);
                addNotification('‚ùå Error: ' + error.message, 'error');
                if (startBtn) {
                    startBtn.disabled = false;
                    startBtn.innerHTML = '‚ñ∂Ô∏è Start Stream';
                }
            }
        }

        // Renamed to stopStream cleanup logic is mostly same
>>>>>>> Stashed changes
        function stopStream() {
            console.log('üõë Stopping stream... Current viewers:', stats.viewers);
            
            // Stop local media
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                document.getElementById('main-video').srcObject = null;
                localStream = null;
            }

<<<<<<< Updated upstream
            // Disconnect LiveKit and cleanup
=======
            // Cleanup File Source
            if (videoFileElement) {
                videoFileElement.pause();
                videoFileElement.src = "";
                videoFileElement.remove();
                videoFileElement = null;
            }

            // Disconnect LiveKit
>>>>>>> Stashed changes
            if (livekitRoom) {
                // Remove all event listeners to prevent duplicate handlers
                livekitRoom.removeAllListeners();
                livekitRoom.disconnect();
                livekitRoom = null;
                console.log('‚úÖ LiveKit room disconnected and cleaned up');
            }

            // Close WebSockets
            if (chatWebSocket) chatWebSocket.close();
            if (reactionsWebSocket) reactionsWebSocket.close();

            // Reset state
            stopDurationTimer();
            isStreaming = false;
            document.getElementById('live-indicator').classList.remove('active');
            
            // Unregister stream from directory
            unregisterStreamFromDirectory();
            
            // Reset stats
            stats.viewers = 0;
            updateStats();
            
            updateUIState();
            updateConnectionStatus('disconnected');
            addNotification('‚èπÔ∏è Stream stopped', 'success');

            // Show Start Button again
            document.getElementById('btn-start-stream').style.display = 'block';
            document.getElementById('btn-start-stream').disabled = false;
            document.getElementById('btn-start-stream').innerHTML = '‚ñ∂ B·∫Øt ƒë·∫ßu Stream';
        }

        async function shareScreen() {
<<<<<<< Updated upstream
=======
            if (!isStreaming || !livekitRoom) {
                addNotification('‚ö†Ô∏è You must start streaming first', 'warning');
                return;
            }

>>>>>>> Stashed changes
            try {
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: { displaySurface: 'monitor' }
                });

<<<<<<< Updated upstream
                const videoTrack = screenStream.getVideoTracks()[0];
                
                if (localStream) {
                    const audioTrack = localStream.getAudioTracks()[0];
                    const newStream = new MediaStream([videoTrack]);
                    if (audioTrack) newStream.addTrack(audioTrack);
                    
                    document.getElementById('main-video').srcObject = newStream;
                    localStream = newStream;
                } else {
                    document.getElementById('main-video').srcObject = screenStream;
                    localStream = screenStream;
                }

                addNotification('üñ•Ô∏è Screen sharing started', 'success');
=======
                // Replace track in LiveKit
                if (localVideoTrack) {
                    await livekitRoom.localParticipant.unpublishTrack(localVideoTrack);
                    localVideoTrack.stop();
                    localVideoTrack = new LivekitClient.LocalVideoTrack(newVideoTrack);
                    await livekitRoom.localParticipant.publishTrack(localVideoTrack, {
                        source: LivekitClient.Track.Source.ScreenShare,
                        simulcast: true
                    });
                }

                if (localStream) {
                    localStream.getVideoTracks().forEach(t => {
                        localStream.removeTrack(t);
                        t.stop();
                    });
                    localStream.addTrack(newVideoTrack);
                }

                newVideoTrack.onended = () => {
                    addNotification('‚èπÔ∏è Screen sharing ended by user', 'warning');
                };

                addNotification('üñ•Ô∏è Switched to Screen Share', 'success');
>>>>>>> Stashed changes
            } catch (error) {
                console.error('Error sharing screen:', error);
                addNotification('‚ùå Failed to share screen', 'error');
            }
        }

        function connectWebSockets() {
            try {
                chatWebSocket = new WebSocket(WS_URL);
                chatWebSocket.onopen = () => console.log('‚úÖ Chat WebSocket Connected');

                reactionsWebSocket = new WebSocket(WS_URL);
                reactionsWebSocket.onopen = () => console.log('‚úÖ Reactions WebSocket Connected');
            } catch (e) {
                console.warn("WebSocket init failed:", e);
            }
        }

        function toggleMic() {
            if (!localStream) return;

            const audioTracks = localStream.getAudioTracks();
            if (audioTracks.length > 0) {
                micEnabled = !micEnabled;
                audioTracks[0].enabled = micEnabled;
                updateUIState();
                addNotification(micEnabled ? 'üé§ Microphone enabled' : 'üîá Microphone muted', 'success');
            }
        }

        async function toggleCamera() {
            if (!isStreaming) return;

            try {
                if (cameraEnabled) {
<<<<<<< Updated upstream
                    // Turn off camera
                    if (localStream) {
                        localStream.getVideoTracks().forEach(track => {
                            if (track.label.includes('camera') || track.label.includes('webcam')) {
                                track.stop();
                            }
                        });
=======
                    // Turn OFF Camera
                    if (localVideoTrack) {
                        // Check if it's actually a camera track or screen share?
                        // If source is camera, we mute/stop it.
                        if (localVideoTrack.source === LivekitClient.Track.Source.Camera) {
                            await localVideoTrack.mute();
                            // Optional: stop track to release hardware light, but mute is faster toggle
                        } else {
                            // It is screen share? Then we just stop tracking it as "Camera Enabled"
                        }
                    }
                    cameraEnabled = false;
                    addNotification('üì∑ Camera OFF', 'success');
                } else {
                    // Turn ON Camera
                    // 1. If we have a muted camera track, just unmute
                    if (localVideoTrack && localVideoTrack.source === LivekitClient.Track.Source.Camera) {
                        await localVideoTrack.unmute();
                        cameraEnabled = true;
                        addNotification('üì∑ Camera ON (Unmuted)', 'success');
                    } else {
                        // 2. We don't have a camera track (was screen share, or never started) -> Create New
                        addNotification('üì∑ Starting Camera...', 'info');

                        // Stop existing video track if it's e.g. screen share
                        if (localVideoTrack) {
                            await livekitRoom.localParticipant.unpublishTrack(localVideoTrack);
                            localVideoTrack.stop();
                        }

                        const cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
                        const newVideoTrack = cameraStream.getVideoTracks()[0];

                        localVideoTrack = new LivekitClient.LocalVideoTrack(newVideoTrack);
                        await livekitRoom.localParticipant.publishTrack(localVideoTrack, {
                            source: LivekitClient.Track.Source.Camera,
                            simulcast: true
                        });

                        // Update Preview
                        if (localStream) {
                            localStream.getVideoTracks().forEach(t => t.stop());
                            localStream = new MediaStream([newVideoTrack]);
                            if (localAudioTrack) localStream.addTrack(localAudioTrack.mediaStreamTrack);
                            document.getElementById('main-video').srcObject = localStream;
                        }

                        cameraEnabled = true;
                        addNotification('üì∑ Camera ON', 'success');
>>>>>>> Stashed changes
                    }
                    cameraEnabled = false;
                    addNotification('üìπ Camera disabled', 'success');
                } else {
                    // Turn on camera
                    const cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
                    const videoTrack = cameraStream.getVideoTracks()[0];
                    
                    if (localStream) {
                        localStream.addTrack(videoTrack);
                    }
                    cameraEnabled = true;
                    addNotification('üìπ Camera enabled', 'success');
                }
                updateUIState();
            } catch (error) {
                console.error('Error toggling camera:', error);
                addNotification('‚ùå Failed to toggle camera: ' + error.message, 'error');
            }
        }

        async function selectQuality(btn) {
            document.querySelectorAll('.quality-btn').forEach(b => b.classList.remove('active'));
            // Refactored to finding class since I changed button structure slightly? No, keeping class quality-btn
            // Wait, in my new HTML I used btn-secondary style but kept quality-btn class.
            // The Original JS adds 'active' class. I need to make sure CSS handles .active

            // Wait, I didn't add .active style for buttons in my new CSS. Let me fix that implicity or rely on the JS adding it and it just working? 
            // It adds class 'active'. I should add a style for it in the head.

            btn.classList.add('active');
            currentQuality = btn.dataset.quality;

<<<<<<< Updated upstream
        function connectWebSockets() {
            try {
                // Chat WebSocket
                chatWebSocket = new WebSocket(`${WS_URL}/chat/ws?room_name=${ROOM_NAME}&user_id=${USER_ID}`);
                
                chatWebSocket.onopen = () => {
                    console.log('‚úÖ Chat WebSocket connected');
                    updateConnectionStatus('connected');
                };

                chatWebSocket.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    addChatMessage(message);
                    stats.messages++;
                    stats.messagesLastMinute++;
                    updateStats();
                };

                chatWebSocket.onerror = (error) => {
                    console.error('‚ùå Chat WebSocket error:', error);
                };

                // Reactions WebSocket
                reactionsWebSocket = new WebSocket(`${WS_URL}/reactions/ws?room_name=${ROOM_NAME}`);
                
                reactionsWebSocket.onopen = () => {
                    console.log('‚úÖ Reactions WebSocket connected');
                };

                reactionsWebSocket.onmessage = (event) => {
                    const reaction = JSON.parse(event.data);
                    showReactionAnimation(reaction);
                    stats.reactions++;
                    stats.reactionsLastMinute++;
                    
                    const type = reaction.type || reaction.reaction_type;
                    reactionCounts[type] = (reactionCounts[type] || 0) + 1;
                    
                    updateStats();
                    updateReactionStats();
                };

                reactionsWebSocket.onerror = (error) => {
                    console.error('‚ùå Reactions WebSocket error:', error);
                };
            } catch (error) {
                console.error('Error connecting WebSockets:', error);
                addNotification('‚ùå Failed to connect WebSockets', 'error');
=======
            addNotification(`üìä Applying quality constraints: ${currentQuality}...`, 'info');

            if (localVideoTrack && localVideoTrack.mediaStreamTrack) {
                let constraints = {};
                if (currentQuality === '1080p') {
                    constraints = { width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 } };
                } else if (currentQuality === '144p') {
                    constraints = { width: { ideal: 256 }, height: { ideal: 144 }, frameRate: { ideal: 15 } };
                } else {
                    constraints = { width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 } };
                }

                try {
                    await localVideoTrack.mediaStreamTrack.applyConstraints(constraints);
                    const settings = localVideoTrack.mediaStreamTrack.getSettings();
                    console.log('‚úÖ Applied constraints:', settings);
                    addNotification(`‚úÖ Resolution set to: ${settings.width}x${settings.height}`, 'success');
                } catch (err) {
                    console.error('Failed to apply constraints:', err);
                }
            } else {
                addNotification('‚ö†Ô∏è No active video track to configure', 'warning');
>>>>>>> Stashed changes
            }
        }

        async function sendChatMessage() {
            const input = document.getElementById('chat-input');
            const content = input.value.trim();

            if (!content) return;

            try {
                if (livekitRoom && livekitRoom.state === 'connected') {
<<<<<<< Updated upstream
                    console.log('üì§ Sending chat via LiveKit DataChannel...');
                    
=======
>>>>>>> Stashed changes
                    const message = {
                        type: 'chat',
                        sender_name: USER_DISPLAY_NAME,
                        content: content,
                        timestamp: new Date().toISOString()
                    };

                    const encoder = new TextEncoder();
                    const data = encoder.encode(JSON.stringify(message));
<<<<<<< Updated upstream
                    
                    // Send to all participants via DataChannel
                    await livekitRoom.localParticipant.publishData(data, { reliable: true });
                    
                    console.log('‚úÖ Chat sent via LiveKit DataChannel');
                    
                    input.value = '';
                    
                    // Add to local chat immediately
=======
                    await livekitRoom.localParticipant.publishData(data, { reliable: true });

                    input.value = '';
>>>>>>> Stashed changes
                    addChatMessage(message);
                    stats.messages++;
                    updateStats();
                    
                } else {
                    addNotification('‚ùå Not connected to room', 'error');
                }
            } catch (error) {
                console.error('Error sending message:', error);
            }
        }

        async function sendReaction(type) {
            try {
                if (livekitRoom && livekitRoom.state === 'connected') {
<<<<<<< Updated upstream
                    console.log('üì§ Sending reaction via LiveKit DataChannel:', type);
                    
=======
>>>>>>> Stashed changes
                    const reaction = {
                        type: 'reaction',
                        user_name: USER_DISPLAY_NAME,
                        reaction_type: type,
                        x: Math.random() * 0.8 + 0.1,
                        y: 0.8,
                        timestamp: new Date().toISOString()
                    };

                    const encoder = new TextEncoder();
                    const data = encoder.encode(JSON.stringify(reaction));
<<<<<<< Updated upstream
                    
                    // Send to all participants via DataChannel
                    await livekitRoom.localParticipant.publishData(data, { reliable: false });
                    
                    console.log('‚úÖ Reaction sent via LiveKit DataChannel');
                    
                    // Show locally
                    showReactionAnimation(reaction);
                    stats.reactions++;
                    updateStats();
                    
                } else {
                    console.warn('‚ö†Ô∏è LiveKit room not connected. Cannot send reaction.');
=======
                    await livekitRoom.localParticipant.publishData(data, { reliable: false });

                    showReactionAnimation(reaction);
                    stats.reactions++;
                    updateStats();

>>>>>>> Stashed changes
                }
            } catch (error) {
                console.error('Error sending reaction:', error);
            }
        }

        function addChatMessage(message) {
            const container = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-message';
<<<<<<< Updated upstream
            
            const time = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span class="message-sender">${message.sender_name || 'User'}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-content">${message.content}</div>
            `;
            
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
            
=======
            messageDiv.innerHTML = `<span class="sender">${message.sender_name || 'User'}:</span><span class="content">${message.content}</span>`;
            container.appendChild(messageDiv);
            container.scrollTop = container.scrollHeight;
>>>>>>> Stashed changes
            document.getElementById('chat-count').textContent = stats.messages;
        }

        function addSystemMessage(text) {
            const container = document.getElementById('chat-messages');

            const div = document.createElement('div');
            div.style.color = '#adadb8'; // --text-alt
            div.style.fontSize = '0.8em';
            div.style.textAlign = 'center';
            div.style.margin = '8px 0';
            div.style.fontStyle = 'italic';
            div.innerHTML = text;

            container.appendChild(div);
            container.scrollTop = container.scrollHeight;
        }

        function showReactionAnimation(reaction) {
            const overlay = document.getElementById('reaction-overlay');
            const emoji = document.createElement('div');
            emoji.className = 'floating-reaction';
<<<<<<< Updated upstream
            
            // Get reaction type - try reaction_type first, then type (but not if type='reaction')
            const reactionType = reaction.reaction_type || (reaction.type !== 'reaction' ? reaction.type : null);
            emoji.textContent = getReactionEmoji(reactionType);
            
=======
            const reactionType = reaction.reaction_type || (reaction.type !== 'reaction' ? reaction.type : null);
            emoji.textContent = getReactionEmoji(reactionType);
>>>>>>> Stashed changes
            emoji.style.left = (reaction.x ? reaction.x * 100 : Math.random() * 90) + '%';
            emoji.style.bottom = '0'; // force bottom start
            overlay.appendChild(emoji);
            setTimeout(() => emoji.remove(), 3000);
        }

        function getReactionEmoji(type) {
            const emojis = {
                like: 'üëç', heart: '‚ù§Ô∏è', wow: 'üòÆ', laugh: 'üòÇ',
                sad: 'üò¢', fire: 'üî•', clap: 'üëè', party: 'üéâ'
            };
            return emojis[type] || '‚ù§Ô∏è';
        }

        function updateReactionStats() {
            // Placeholder for new UI - we don't have a dedicated reaction stat container visible anymore to save space
            // But we keep the function to prevent errors
        }

        function addNotification(message, type = 'success') {
<<<<<<< Updated upstream
            const container = document.getElementById('notifications-list');
            const notification = document.createElement('div');
            notification.className = `notification-item ${type === 'error' ? 'error' : type === 'warning' ? 'warning' : ''}`;
            
            const time = new Date().toLocaleTimeString('vi-VN', { hour: '2-digit', minute: '2-digit' });
            
            notification.innerHTML = `
                <div>${message}</div>
                <div class="notification-time">${time}</div>
            `;
            
            container.insertBefore(notification, container.firstChild);
            
            // Keep only last 10 notifications
            while (container.children.length > 10) {
                container.removeChild(container.lastChild);
            }
=======
            // Basic alert for now or console, detailed notification list is hidden in new UI to simplify
            console.log(`[${type.toUpperCase()}] ${message}`);
>>>>>>> Stashed changes
        }

        function updateStats() {
            document.getElementById('stat-current-viewers').textContent = stats.viewers;
            document.getElementById('stat-messages').textContent = stats.messages;
            document.getElementById('stat-reactions').textContent = stats.reactions;

            // Sync multiple ID targets if they exist
            if (document.getElementById('stream-viewers')) document.getElementById('stream-viewers').textContent = stats.viewers;
            if (document.getElementById('viewers-count')) document.getElementById('viewers-count').textContent = stats.viewers;
        }

        function updateUIState() {
            document.getElementById('btn-start-stream').disabled = isStreaming;
            document.getElementById('btn-stop-stream').disabled = !isStreaming;
<<<<<<< Updated upstream
            document.getElementById('btn-screen-share').disabled = !isStreaming;
            
            const micBtn = document.getElementById('btn-toggle-mic');
            micBtn.textContent = micEnabled ? 'üé§ Mic: ON' : 'üîá Mic: OFF';
            micBtn.className = micEnabled ? 'btn btn-primary' : 'btn btn-secondary';
            
=======
            document.getElementById('btn-screen-share').disabled = isStreaming ? false : true;
            // Note: Screen share usually enabled only during stream in this logic, kept original logic but fixed "disabled" state inversion logic error if existed

            const micBtn = document.getElementById('btn-toggle-mic');
            micBtn.textContent = micEnabled ? 'üé§ Mic: ON' : 'üîá Mic: OFF';
            if (!micEnabled) micBtn.classList.add('btn-danger'); else micBtn.classList.remove('btn-danger');

>>>>>>> Stashed changes
            const camBtn = document.getElementById('btn-toggle-camera');
            camBtn.textContent = cameraEnabled ? 'üìπ Camera: ON' : 'üìπ Camera: OFF';
            if (cameraEnabled) {
                camBtn.classList.add('btn-primary');
                camBtn.classList.remove('btn-secondary');
            } else {
                camBtn.classList.add('btn-secondary');
                camBtn.classList.remove('btn-primary');
            }
        }

        function updateConnectionStatus(status) {
            const badge = document.getElementById('connection-status');
<<<<<<< Updated upstream
            
=======
>>>>>>> Stashed changes
            if (status === 'streaming') {
                badge.className = 'connection-badge badge-streaming';
                badge.textContent = 'Tr·ª±c ti·∫øp';
            } else if (status === 'connected') {
                badge.className = 'connection-badge badge-connected';
                badge.textContent = 'ƒê√£ k·∫øt n·ªëi';
            } else {
                badge.className = 'connection-badge badge-disconnected';
                badge.textContent = 'Offline';
            }
        }

        function startDurationTimer() {
            durationInterval = setInterval(() => {
                if (streamStartTime) {
                    const duration = Math.floor((Date.now() - streamStartTime) / 1000);
                    const minutes = Math.floor(duration / 60);
                    const seconds = duration % 60;
<<<<<<< Updated upstream
                    
                    const formatted = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    document.getElementById('stat-total-duration').textContent = formatted;
                    document.getElementById('stream-duration').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
=======
                    const formatted = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    document.getElementById('stream-duration').textContent = formatted;
>>>>>>> Stashed changes
                }
            }, 1000);
        }

        function stopDurationTimer() {
            if (durationInterval) {
                clearInterval(durationInterval);
                durationInterval = null;
            }
        }

        // Reset rate counters every minute
        setInterval(() => {
            stats.messagesLastMinute = 0;
            stats.reactionsLastMinute = 0;
            updateStats();
        }, 60000);
    </script>
</body>
</html>
